1. 尾部的0

设计一个算法，计算出n阶乘中尾部零的个数

思路：数据中如果有5的倍数的话就多一个0,25的倍数话多两个0,但是注意了如果通用算了5的倍数的时候其实也算了25的倍数所以思路很简单，就是算算到n为止有多少5,25,125...个倍数就行了

```java
public class Solution {
    /*
     * @param n: An integer
     * @return: An integer, denote the number of trailing zeros in n!
     */
    public long trailingZeros(long n) {
        long count=0;//一定是long~~~~
        for(int i=1;Math.pow(5,i)<=n;i++)
            count+=n/(long)Math.pow(5,i);
        return count;
    }
}
```
反思，好久没有动脑了，只是看到了表面的东西，没有深入思考，要恢复以前对数字敏感的状态

2. 提及数字
计算数字k在0到n中的出现的次数，k可能是0~9的一个数值

基本的排列组合 比如 123 这个数组要算 1出现的个数 就算 ××1 ×1× 1×× 分别有多少个就可以了，但是又很多的边界问题比如

比如：001可以存在，但是如果这个数组只有一位比如 9 那么就不能有 01  

验证一下为什么这么做对，因为 在计算××1 的时候 想 ×11 和 111 这种情况只计算了一次，所以再计算×1× 和 1×× 的时候就不需要去重了

```java
public class Code2 {
    public static void main(String[] args) {
        Code2 main2 = new Code2();
        long nowTime = new Date().getTime();
        for (int i = 10000; i < 99999; i++) {
            main2.digitCounts3(2,i);
        }
        long endTime = new Date().getTime();
        System.out.println(endTime - nowTime);
    }
    /**
     * 复杂做法，使用计算法
     */
    public int digitCounts(int k, int n) {
        int item;
        int beforeNumber;
        int base = 10;
        int all = 0;
        do {
            beforeNumber = n / base * base;
            item = (n - beforeNumber) / (base / 10);
            if (item > k) {
                all += (n / base + 1) * (base / 10);
            } else if (item == k) {
                all += (n / base) * (base / 10) + (n % (base / 10) + 1);// 1 12 这种情况下注意有全零的数字   21345这个数据
            } else {
                all += (n / base) * (base / 10);
            }
            base *= 10;
        } while (beforeNumber != 0);
        if (k == 0 && base > 100) {//01 02 不算数
            all -= base / 100;
        }
        return all;
    }
    //简单暴力方法
    public int digitCounts3(int k, int n) {
        // write your code here
        int sum=0;
        for(int i=0;i<=n;i++){
            int num=i;
            while(num/10!=0){
                if(num%10==k){
                    sum++;
                }
                num=num/10;
            }
            if(num==k)
                sum++;
        }
        return sum;
    }
}
```

反思：思路要灵活重要的是脑子的反应要迅速，这道题目不难要 注意边界问题，为什么这么做正确的原因区间冗余是非常重要的

3. 丑数

设计一个算法，找出只含素因子2，3，5 的第 n 小的数。

符合条件的数如：1, 2, 3, 4, 5, 6, 8, 9, 10, 12...

这道题使用递推的思想最好，高级递推（有状态的递推）

有题目可以知道的

