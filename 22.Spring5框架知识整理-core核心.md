### 依赖注入和控制反转

IOC   inversion of control  控制反转

DI   Dependency Injection  依赖注入

####依赖注入

当然是某个对象依赖于IoC/DI的容器，对象需要IoC/DI的容器来提供对象需要的外部资源，IoC/DI的容器 注入 某个对象并且注入某个对象所需要的外部资源，由IoC/DI的容器来控制对象了，根本上是控制对象实例的创建

#### 控制反转
如果要在A里面使用C，你会怎么做呢？当然是直接去创建C的对象，也就是说，是在A类中主动去获取所需要的外部资源C，这种情况被称为正向的。那么什么是反向呢？就是A类不再主动去获取C，而是被动等待，等待IoC/DI的容器获取一个C的实例，然后反向的注入到A类中


### spring IOC 配置文件

```java
1. bean标签就是计入进spring bean工厂中的类 属性 id 是他的名字 class是,底层进行 class 反射的类底层默认使用的反射生成实例 所以 bean必须有无参的构造函数
     相关参数
	id - 属性的名字-不能重复
	class - 属性的实现类
	parent - 指的是这个bean 要将xml文件中那个bean的标签加入进来，通常和abstract标记连用
		继承的属性子类将不能继承父类的depends-on autowire singleton scope lazy-init属性
	abstract - spring容器将不会尝试对他进行单例话而只是用来作为模板用在parent的属性上
	autowrite - bean对其bean的引用可以自动进行，而不一定用ref=的方式显式声明，有五种表示方法
		no  byname-根据注入的属性名（set方法去掉set小写首字母）称自动的注入相关的bean的id
		bytype-查找同名后者同类型的属性超过两个会报错
		constructor - 使用构造器中的参数类型进行匹配
	autowirte-candidate- 在bean的自动装配(autowrite)方法中是否忽略这个方法
	depend-on 表示这个方法的实例化优先于那个实例-强制初始化bean实例
	name - 表示这个属性的别名
	lazy-init - 表示spring框架将会进行延迟加载bean方法-（创建的时候不会调用 set方法进行实例化操作）使用的时候才进行创建
	scope-指明bean实例化的时候使用的模式 
		singleton-单利模式 单例模式相比较prototype 速度要快的多
		prototype-模版模式 request-对于一次request请求
		request作用域的bean实例只生成一个实例
		session -对于一次session session作用域将只生成一次请求
	factory-method 指定spring的加载方式是使用工厂方法的时候调用这个工厂方法中的那个类实现相关的方法
	factory-bean 指定相关的工厂方法进行相关的配置
	destroy-method  指定销毁的方法
	init-method 指定初始化的方法
2.property 是要进行依赖注入 的成员变量
		name表示变量名称 
		ref表示要注入的其他bean 实例
		value 表示要进行注入的基本类型 注意不能注入自己定义的变量 
3.spring框架默认使用无参数的构造器 如果想使用有参数的构造器需要使用构造器注入
	constructor-agr-标签中可以传入几个参数 
		index 	表示第几个参数
		name 	表示参数的名称
		ref 	同上
		value  	同上
		type 	制定参数的类型，可以使用非基本类型
4. beans 标签 表示一堆bean的集合 里面的属性表示是应用于所有有关这个的方法
	default-lazy-init
	default-merge -制定beans下所有的默认合并行为
	default-autowire
	dafault-autowire-condiadates
	default-init-method - 所有bean的默认初始化行为
	default-destroy-method - 所有bean的默认回收方法
```

#### parent abstract和list  map set Properties   属性使用

```xml
<bean id="baseBeanForDemoOne" abstract="true">
    <description>联系spring的使用使用抽象类进行操作</description>
    <property name="string" value="this is string"></property>
    <property name="number" value="123"></property>
</bean>
<!-- parent list  map  属性使用 -->
<bean id="demoOne" class="b_spring.a_spring的bean的依赖注入.bean.DemoBeanOne" parent="baseBeanForDemoOne">
    <property name="items"><!-- 使用list方法进行注入  -->
        <list value-type="java.lang.String">
            <value>one</value>
            <value>two</value>
            <value>three</value>
            <value type="java.lang.String">four</value>
        </list>
    </property>
    <property name="itemMap"><!-- 使用map方法进行注入 -->
        <map key-type="java.lang.String" value-type="java.lang.Integer">
            <entry key="one" value="123"></entry>
            <entry key="two" value="223"></entry>
        </map>
    </property>
    <property name="set">
        <set value-type="java.lang.String">
            <value>ddddd</value>
        </set>
    </property>
    <property name="properties">
        <props>
            <prop key="pro">eeee</prop>
        </props>
    </property>
</bean>
```

```java
import java.util.ArrayList;
import java.util.HashMap;
public class DemoBeanOne {
## 	//注意使用spring的set注入方法的时候必须提供set方法
	private  String string;
	private  int number;
	private ArrayList<String> items;
	private HashMap<String, Integer> itemMap;
	private Set<String> set;
	private Properties properties;
	//注意使用spring的set注入方法的时候必须提供set方法
	.......get和set的方法.......
}
```

parent 和 abstract 只是相当于在配置文件中指定一个参数的继承方法，相当于实现一个参数的模板，而集合类型的配置，例子中使用了基本类型使用value标签进行配置其实和可以传入bean的引用。

```xml
<property name="list">
    <list value-type="bean.People">
        <!--传入制定的bean的名称-->
        <ref bean="jjj"></ref>
    </list>
</property>
<property name="map">
   <map key-type="java.lang.String" value-type="bean.People">
        <entry key="one" value-ref="jjj"></entry>
    </map>
</property>
<property name="set">
    <set value-type="bean.People">
        <ref bean="jjj"></ref>
    </set>
</property>
```

#### 获取bean容器

使用applicationContext 获得 spring 容器  而 BeanFactory是 application的父类   二者区别

applicationContext接口,它由BeanFactory接口派生而来，因而提供BeanFactory所有的功能。ApplicationContext以一种更向面向框架的方式工作以及对上下文进行分层和实现继承，ApplicationContext包还提供了以下的功能：

- MessageSource, 提供国际化的消息访问
- 资源访问，如URL和文件
- 事件传播
- 载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层

其他区别：

- BeanFactroy采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时(调用getBean())，才对该Bean进行加载实例化，这样，我们就不能发现一些存在的Spring的配置问题。而ApplicationContext则相反，它是在容器启动时，一次性创建了所有的Bean。这样，在容器启动时，我们就可以发现Spring中存在的配置错误。 
- BeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，但两者之间的区别是：BeanFactory需要手动注册，而ApplicationContext则是自动注册

```java
ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext("/a_bean.xml");
ApplicationContext applicationContext = new  FileSystemXmlApplicationContext("a_bean.xml");
```

#### autowrite  + autowirte-candidate  lazy-init（spring只用在使用的时候才会加载bean）

> 通过 名称或者类型自动装载但是要注意一个问题就是唯一性（姓名的唯一性和类型的唯一性），注意，在xml中使用autowrite的时候如果使用的list集合就可以出现相同的类型的情况，spring会将所有的正确的类型注入到集合中

autowrite : 只用自动装配的方法
autowrite-candidate：忽略自动装配（也就是是说spring在查找可自动装配的候选项时忽略这个选项，就是不能被自动装配）

```java
<bean id="demoTwo" autowire="byName" depends-on="demoOne" class="b_spring.a_spring的bean的依赖注入.bean.DemoBeanTwo"></bean>
<bean id="demoTwo2" autowire="byType" depends-on="demoOne" class="b_spring.a_spring的bean的依赖注入.bean.DemoBeanTwo"></bean>
```

#### scope

spring有 如下的作用域（在作用域内默认使用单例），表示这个对象在这一个区域的独立性（比如单例在不同的区域就是表现的不同），singleton ， prototype，request ，session ，application（servletcontext做用域），websocket后面的四种只用在使用springmvc或者进行一些配置并且使用的web应用的时候才有效，配置如下：

```xml
<web-app>
    ...
    <listener>
        <listener-class>
            org.springframework.web.context.request.RequestContextListener
        </listener-class>
    </listener>
    ...
</web-app>

<web-app>
    ...
    <filter>
        <filter-name>requestContextFilter</filter-name>
        <filter-class>org.springframework.web.filter.RequestContextFilter</filter-class>
    </filter>
    <filter-mapping>
        <filter-name>requestContextFilter</filter-name>
        <url-pattern>/*</url-pattern>
    </filter-mapping>
    ...
</web-app>
```

注意了：如果长的scope引用短的scope中的bean 将会导致短的scope在长的scope中无法随着短的scope生命周期的结束而结束，而是以长的scope作为标准，如果想要以完美的方法需要进行如下的配置，添加<aop:scoped-proxy/>

```xml
<bean id="userPreferences" class="com.foo.UserPreferences" scope="session">
    <aop:scoped-proxy/>
</bean>

<bean id="userManager" class="com.foo.UserManager">
    <property name="userPreferences" ref="userPreferences"/>
</bean>
```

这种方法让传入长的scope中的对象不是短的scope的bean而是这个短的scope的代理使用的是cglib（aop），这个代理只随着session的创建而创建，销毁而销毁。注意cglib只能代理公有方法，所以不要调用非公有方法

也可以使用jdk代理 <aop:scoped-proxy proxy-target-class="false"/>， 这个方法将会自动的使用的jdk代理。

一个例子：
配置文件：

```xml
<bean id="demoThree" class="b_spring.a_spring的bean的依赖注入.bean.DemoBeanThree" scope="prototype" lazy-init="true">
	<property name="string" value="this is demo three"></property>
	<property name="number" value="123"></property>
	<property name="demoBeanOne" ref="demoOne"></property>
</bean>
<bean id="demoFour" class="b_spring.a_spring的bean的依赖注入.bean.DemoBeanFour" lazy-init="true">
	<property name="string" value="this is demo four"></property>
	<property name="number" value="123"></property>
	<property name="beanThree" ref="demoThree"></property>
</bean>
```

javabean：

```java
public class DemoBeanThree {
	private String string;
	private int number;
	private DemoBeanOne demoBeanOne;
	.....get 和 set 方法
}
public class DemoBeanFour {
	private String string;
	private int number;
	private DemoBeanThree beanThree;
	.....get 和 set 方法
}
```

测试类：

```java
public void testFour() {
	DemoBeanThree d= context.getBean("demoThree",DemoBeanThree.class);
	DemoBeanThree d2= context.getBean("demoThree",DemoBeanThree.class);
	DemoBeanFour dFour=context.getBean("demoFour", DemoBeanFour.class);
	DemoBeanFour dFour2=context.getBean("demoFour", DemoBeanFour.class);
	System.out.println(d==d2);
	System.out.println("-------");//注意使用原型模式注入但单例模式的时候,或者使用单例模式注入原型模式的时候，一次操作中注入的对象是相同的
	System.out.println(d.getDemoBeanOne()==d2.getDemoBeanOne());
	System.out.println("-------");
	System.out.println(dFour.getBeanThree()==dFour2.getBeanThree());
	dFour.getBeanThree().setNumber(1233);
	System.out.println(dFour2.getBeanThree().getNumber());
}
```

> 注意一个结论：注意使用原型模式注入但单例模式的时候,或者使用单例模式注入原型模式的时候，一次操作中注入的对象是相同的 ，如果想要让单例模式注入原型模式的时候取得数据为原型模式就要使用lookup方法

#### lookup method
使用lookup 方法，其实本质上就是让一个单例bean使用一个原型bean的时候，去实现这个单例bean中的一个抽象方法，让这个抽象方法返回一个单例bean

一个有抽象方法的单例bean

```java
public abstract class BeanOne {
	private BeanTwo beanTwo;
	public abstract BeanTwo getBeanTwo();
	public void say(){
		getBeanTwo().say();
	}
	public void setBeanTwo(BeanTwo beanTwo) {
		this.beanTwo = beanTwo;
	}
}
```

对应的原型bean

```java
public class BeanTwo {
	public void say(){
		System.out.println(this);
	}
}
```
main函数中的方法

```java
ApplicationContext context = new ClassPathXmlApplicationContext("bean.xml");
BeanOne beanOne1 = context.getBean("beanone",BeanOne.class);
BeanOne beanOne2 = context.getBean("beanone",BeanOne.class);
BeanOne beanOne3 = context.getBean("beanone",BeanOne.class);
beanOne1.say();
beanOne2.say();
beanOne3.say();
```

配置文件

```xml
	<bean id="beanone" class="j_spring框架出处理单例模式下的非单例成员.BeanOne">
		<lookup-method name="getBeanTwo" bean="beanTwo"/>
		<!-- spring框架在抽象类中将会自动使用动态代理实现这个抽象方法，讲指定的bean对象进行返回
				如果对象实现了借口  spring框架将会使用jdk代理 否则使用cglib代理  推荐使用接口
		 -->
	</bean>
```

输出结果

```java
i_spring框架出处理单例模式下的非单例成员.BeanTwo@5512cb5f
i_spring框架出处理单例模式下的非单例成员.BeanTwo@5bf3101d
i_spring框架出处理单例模式下的非单例成员.BeanTwo@230b9680
```
可以看出BeanTwo的结果是不同的

#### factory-method   factory-bean  constructor-arg

> 这个工厂方法并不是我们去使用的而是让spring容器使用的工厂方法，spring容器使用这个工厂方法进行实例的生成，在spring中使用构造注入的形式调用指定的工厂法，并传入属性(可以理解成使用方法作为构造函数进行注入)，引申spring也能使用构造注入但是需要提供对应的构造函数

```xml
<bean id="staticFactory" class="b_spring.a_spring的bean的依赖注入.bean.DemoBeanStaticFactory" factory-method="createBeanOne">
	<constructor-arg index="0" value="staticfactory"></constructor-arg>
	<constructor-arg index="1" value="222"></constructor-arg>
</bean>
<!-- 使用动态方法进行构建 -->
<bean id="getOne" class="b_spring.a_spring的bean的依赖注入.bean.DemoBeanFactory"></bean>
<bean id="beanfactory" factory-bean="getOne" factory-method="getDemoBeanOne">
	<constructor-arg index="0" value="beanfactory"></constructor-arg>
	<constructor-arg index="1" value="222"></constructor-arg>
</bean>
```

```java
DemoBeanFour demoBeanOne = context.getBean("staticFactory", DemoBeanFour.class);
DemoBeanFour demoBeanOne2= context.getBean("beanfactory", DemoBeanFour.class);
System.out.println(demoBeanOne.getString()+" "+demoBeanOne2.getString());
```

#### spring 生命周期管理，初始化和销毁

实现方法

1. 继承并且实现 InitializingBean，DisposableBean 接口
2. 在xml文件中bean的属性指明 destroy-method="" init-method="" 对应的方法
3. 使用注解 @PostConstruct and @PreDestroy  @PreConstruct-容器在卸载这个bean的时候将会调用的方法 

spring框架 通过BeanPostProcessor 类来实现生命周期的管理的。

引申优雅关闭spring容器

如果使用的web项目使用webapplication的时候并不需要特殊配置spring框架自动的将相关的各种配置都实现了
如果使用的是非web项目那么需要手动进行配置，通过ConfigurableApplicationContext 类进行配置，使用registerShutdownHook方法优雅停机

```java
ConfigurableApplicationContext applicationContext = 
		new ClassPathXmlApplicationContext("./bean.xml");
applicationContext.registerShutdownHook();
```


### spring 零配置方法

> 所谓零配置，并不是说一点配置都没有了，而是配置很少而已。通过约定来减少需要配置的数量，提高开发效率。更厉害的是spring boot

xml配置文件

```xml
<!-- base-package-指定扫描的包   resource-pattern-粗过滤 -->
<context:component-scan base-package="b_spring.a_spring的bean的依赖注入.bean" resource-pattern="web*/">
        <!-- 可以指定过滤指定的注解或者使用正则表达式 -->
	<context:exclude-filter type="regex" expression="*.*jkl"/><!-- 不作为过滤器 -->
	<context:include-filter type="annotation" expression=".*jkl"/><!-- 作为过滤器 -->
</context:component-scan>
```

注意：必须还要加上如下的注解，这个注解的作用是开启@Autowired，@ Resource ，@ PostConstruct，@ PreDestroy，@PersistenceContext，@Required 各种支持从而不需要在xml文件中配置相关的类

```xml
<context:annotation-config></context:annotation-config>
```

该隐式注册的后处理器包括 AutowiredAnnotationBeanPostProcessor， CommonAnnotationBeanPostProcessor， PersistenceAnnotationBeanPostProcessor，以及前述 RequiredAnnotationBeanPostProcessor



#### spring 类上的注解

这几个注解在使用上其实是一样只是使用不同的名称来体现可读性

```java
@Controller(value="oneinfo")
@Service
@Repository
@Component
@Configurable    Autowire.NO;//等指定是否支持自动装配
```

类属性的注解

```java
@Scope("prototype")//---设置bean对象使用的作用域
@ApplicationScope //作用域简写
@RequestScope //作用域简写
@SessionScope //作用域简写
@DependsOn({"beanTwo"})//相当于xml文件中配置的dependson属性表示依赖关系
@Lazy(true)//表示函数是否进行延迟加载
@Required   //这个注解只能放在setXxxx()方法上，spring检测set方法有没有使用，如果没有使用将会抛出异常
@order和@Priority //见下面啊autowrite方法
@Primary //如果autowrite进行注入的时候存在多个类型并且造成了冲突(使用集合类型就不会出现冲突),解决的办法就是使用@primary,进行这个注解的bean将会优先的进行注入,多个就按照后面的覆盖前面的
```

类中元素上的注解

```java
@Resource(name="beanTwo")//使用这个注解相当于在框架中使用ref  参数可以为空首先是使用byname匹配法然后使用bytype匹配法
@Autowired//将方法中所有的参数都默认使用bytype模式进行自动的依赖注入  找不到type对应的bean或者存在多个bean都会抛出异常，如果制定了required=false的时候将不会抛出异常。
//该注解可以使用在变量 set 或者普通方法上，他会自动的将相关的属性注入进去，如果有多个匹配，可以使用list，数组，set，map进行接收，否则将会报错
@Qualifier("beanTwo")//用来和autowired连用 表示使用自动转配并且指定相关的bean名称进行自动的装配
```

@Autowired 使用方法引申 ：这个注解可以使用在变量 set 或者普通方法上，他会自动的将相关的属性注入进去，如果有多个匹配，可以使用list，数组，set，map进行接收，否则将会报错，如果想要诸如的bean按照顺序，可以使用@order或者@Priority在bean上指定顺序

5.0 新注解 使用@Nullable 可以忽略@Autowired 应在函数上面的时候的参数

```java
@Autowired
public void setMovieFinder(@Nullable MovieFinder movieFinder) {
     ...
}
```
@Autowired对于那些众所周知的解析依赖接口：BeanFactory，ApplicationContext，Environment，ResourceLoader， ApplicationEventPublisher，和MessageSource。这些接口及其扩展接口（如ConfigurableApplicationContext或ResourcePatternResolver）会自动解析，无需特殊设置。

@Autowired，@Inject，@Resource，和@Value注释由Spring处理 BeanPostProcessor实现，这反过来又意味着你不能在您自己的应用这些注释BeanPostProcessor或BeanFactoryPostProcessor类型（如果有的话）。这些类型必须通过XML或使用Spring @Bean方法明确地进行配置 。

5,0新注解 使用@Primary微调基于注释的自动装配
这里指定了相关的java配置类返回的参数
```java
@Configuration
public class MovieConfiguration {
    @Bean
    @Primary
    public MovieCatalog firstMovieCatalog() { ... }
    @Bean
    public MovieCatalog secondMovieCatalog() { ... }
    // ...
}
```
在xml文件中进行如下配置
```xml
 <bean class="example.SimpleMovieCatalog" primary="true">
     <!-- inject any dependencies required by this bean -->
</bean>
```









生命周期控制
```java
@PostConstruct//spring容器在第一次初始化之后将会调用这个方法
@PreConstruct//spring容器在卸载这个对象的时候将会调用这个方法
@PreDestroy//相当于删除的方法在使用这个方法的时候将会在销毁的时候进行回调
```

- @Resource： 默认使用name属性进行自动装配，@Resource 没有指定 name 属性，那么使用 byName 匹配失败后，会退而使用 byType 继续匹配，如果再失败，则抛出异常，将其标注在 BeanFactory 类型、ApplicationContext 类型、ResourceLoader 类型、ApplicationEventPublisher 类型、MessageSource 类型上，那么 Spring 会自动注入这些实现类的实例，不需要额外的操作。
- @Autowired 和 @Qualifier 注解执行自动装配：1.只能是根据类型进行匹配   2. 可以用于 Setter 方法、构造函数、字段，甚至普通方法，前提是方法必须有至少一个参数   3.可以用于数组和使用泛型的集合类型。然后 Spring 会将容器中所有类型符合的 Bean 注入进来。 4,  标注作用于 Map 类型，将容器中所有类型符合 Map 的 value 对应的类型的 Bean 增加进来，用 Bean 的 id 或 name 作为 Map 的 key 5.@Autowired 后面增加一个 @Qualifier 标注，提供一个 String 类型的值作为候选的 Bean 的名字

```java
@Autowired(required=false)
@Qualifier("ppp")
public void setPerson(person p){}
@Autowired(required=false)
public void sayHello(@Qualifier("ppp")Person p,String name){}
```

配置类注解

```java
@Configuration
@ComponentScan(basePackages = {"org.bean"})//扫描指定的包
@PropertySource("needpro.properties")//导入指定的配置文件，可以指定编码格式
```

@value 标签使用spEL 表达式进行配置

```java

@Value("这是spring的配置文件")//传入简单的string类型
private String name;
@Value("#{systemProperties['os.name']}")//使用springEl传入系统属性
private String osName;
@Value("#{T(java.lang.Math).random()*100.0}")//使用EL调用系统方法
private double randomNumber;
@Value("${book.name}")//传入配置文件中指定的参数
private String bookName;
@Value("#{book.name}")//获得指定bean的参数
private String beanINfo;
```

```java
@Bean(name = "abook") //还提供 initMethod he destroyMethod 配置文件等同于在xml中进行配置
@Scope("prototype")
@Profile("pro")  //指定返回bean执行的版本信息可以在容器启动的时候动态的导入
public Book mybook() {
   return new Book();
}
```

### 一个例子

```java
import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import javax.annotation.Resource;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Controller;
@Controller
class Demo1 {
	@Autowired
	@Qualifier("itemService")
	private ItemService itemService;
	@Resource(name = "itemService")
	private ItemService itemService2;
	private String item = "sdfdf";
	public String getItem() {
		return item;
	}
	public void setItem(String item) {
		this.item = item;
	}
	@PostConstruct
	public void init() {
		System.out.println("start");
	}
	@PreDestroy
	public void destory() {
		System.out.println("end");
	}
}
```

### spring4相关注解增强

#### @autowrite注解关联范型（模糊类型增强）

javabean

```java

public class User implements Serializable {
    private Long id;
    private String name;
}
public class Organization implements Serializable {
    private Long id;
    private String name;
}
public abstract class BaseRepository<M extends Serializable> {
    public void save(M m) {
        System.out.println("=====repository save:" + m);
    }
}
@Repository
public class UserRepository extends BaseRepository<User> {
}
@Repository
public class OrganizationRepository extends BaseRepository<Organization> {
}
```

新service

```java
public abstract class BaseService<M extends Serializable> {
    @Autowired
    protected BaseRepository<M> repository;
    public void save(M m) {
        repository.save(m);
    } }
@Service
public class UserService extends BaseService<User> {
}
@Service
public class OrganizationService extends BaseService<Organization> {
}
```

旧service

```java
public abstract class BaseService<M extends Serializable> {
    private BaseRepository<M> repository;
    public void setRepository(BaseRepository<M> repository) {
        this.repository = repository;
    }
    public void save(M m) {
        repository.save(m);
    }
}
@Service
public class UserService extends BaseService<User> {
    @Autowired
    public void setUserRepository(UserRepository userRepository) {
        setRepository(userRepository);
    }
}
@Service
public class OrganizationService extends BaseService<Organization> {
    @Autowired
    public void setOrganizationRepository(OrganizationRepository organizationRepository) {
        setRepository(organizationRepository);
    }
}
```

1.范型注入改进

> 改进：不需要在set方法上在进行一次封装，直接使用@Autowrite进行注入就好了

2.提供map和list注入

```java
@Autowired
private Map<String, BaseService> map;
@Autowired
private List<BaseService> list;
```

> map会这样注入：key是bean名字；value就是所有实现了BaseService的Bean

> list会这样注入：这样会注入所有实现了BaseService的Bean；但是顺序是不确定的，如果我们想要按照某个顺序获取；在Spring4中可以使用@Order或实现Ordered接口来实现（指定加载的顺序）

