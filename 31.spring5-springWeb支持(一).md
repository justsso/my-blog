说道spring的web支持首先就可以想到了spring MVC 的技术(其他的技术还有spring的webflux 以后讨论),从这片博客开始要进行相关知识点的整理.

### spring MVC 整体的架构设计

![](/blogimg/springMVC/1.jpg)

spring 自己的webapplication支持嵌套作用域,通过这个方法可以实现spring applicationcongtext的继承特性(继承特性,子作用域可以访问夫作用域的中的属性,但是父作用域中的属性无法访问子作用域中的属性,具体的使用看HierarchicalBeanFactory)

#### web容器的初始化设置

springMVC 支持使用xml进行配置

```xml
<web-app>
    <listener>
        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
    </listener>
    <context-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>/WEB-INF/app-context.xml</param-value>
    </context-param>
    <servlet>
        <servlet-name>app</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value></param-value>
        </init-param>
        <load-on-startup>1</load-on-startup>
    </servlet>
    <servlet-mapping>
        <servlet-name>app</servlet-name>
        <url-pattern>/app/*</url-pattern>
    </servlet-mapping>
</web-app>
```

从spring5.0 开始 spring官方文档提倡使用接口配置,容器在初始化的时候将会自动的加载这个接口的实现类从而进行配置
spring mvc 的自动化配置是通过 WebApplicationInitializer 接口实现的 但是系统提供了更加高级的接口 AbstractAnnotationConfigDispatcherServletInitializer 

```java
public class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {
    @Override
    protected Class<?>[] getRootConfigClasses() {
        return new Class<?[] { RootConfig.class };
    }
    @Override
    protected Class<?>[] getServletConfigClasses() {
        return new Class<?[] { App1Config.class };
    }
    @Override
    protected String[] getServletMappings() {
        return new String[] { "/app1/*" };
    }
}
```

```java
import org.springframework.web.WebApplicationInitializer;

public class MyWebApplicationInitializer implements WebApplicationInitializer {
    @Override
    public void onStartup(ServletContext container) {
        XmlWebApplicationContext appContext = new XmlWebApplicationContext();
        appContext.setConfigLocation("/WEB-INF/spring/dispatcher-config.xml");

        ServletRegistration.Dynamic registration = container.addServlet("dispatcher", new DispatcherServlet(appContext));
        registration.setLoadOnStartup(1);
        registration.addMapping("/");
    }
}
```

如果使用基于xml 的 spring配置则需要使用这个方法进行相关的调用

```java
public class MyWebAppInitializer extends AbstractDispatcherServletInitializer {
    @Override
    protected WebApplicationContext createRootApplicationContext() {
        return null;
    }
    @Override
    protected WebApplicationContext createServletApplicationContext() {
        XmlWebApplicationContext cxt = new XmlWebApplicationContext();
        cxt.setConfigLocation("/WEB-INF/spring/dispatcher-config.xml");
        return cxt;
    }
    @Override
    protected String[] getServletMappings() {
        return new String[] { "/" };
    }
}
```

如果要添加filter 配置 重构如下的方法

```java
public class MyWebAppInitializer extends AbstractDispatcherServletInitializer {
    // ...
    @Override
    protected Filter[] getServletFilters() {
        return new Filter[] {
            new HiddenHttpMethodFilter(), new CharacterEncodingFilter() };
    }
}
```
这个方法将会为每一个filter 添加一个默认的过滤器,并且自动的添加到对应的display中

这个方法还有一个isisAsyncSupported() 默认情况下返回true 表示spring mvc 框架中的filter 将会异步的处理请求

### 最核心类 DispatcherServlet

如果要说这个类就需要看一下springmvc的流程图

![](/blogimg/1.png);

在这里之前 DispathcerServlet 将会webapplicationcontext的字符串引用放入java中 

```java
public static final String WEB_APPLICATION_CONTEXT_ATTRIBUTE = DispatcherServlet.class.getName() + ".CONTEXT";
```

一个一个看

1. HandlerMapping 

这个类解决了 url地址映射到对应的处理类中，主要有两个实现RequestMappingHandlerMapping-为@RequestMapping 注解提供支持 ，SimpleUrlHandlerMapping，实现简单的url地址映射

2. HandlerExceptionResolver 

这个是试图返回的异常处理包括相关的错误处理方法

3. HandlerIntercepter 

处理相关的接口进行拦截 

4. HandlerAdapter

使用适配器模式，将试图的映射由指定的接口处理

5. 各种resolver 提供视图解析展示的功能

LocaleResolver, LocaleContextResolver，ThemeResolver，MultipartResolver

6. FlashMapManager

处理flash的时候使用的 估计用不到了

### Interception 拦截器

所有的handler 都会被拦截  这个接口提供三个方法

preHandle(..) — before the actual handler is executed

postHandle(..) — after the handler is executed  注意这个方法如果使用@ResponseBody 注解的时候将不会被拦截

afterCompletion(..) — after the complete request has finished
 

####HandlerExceptionResolver springmvc 异常处理

异常处理用于处理@controll 这种接口抛出的各种异常，主要有如下的几种

1. SimpleMappingExceptionResolver 异常类名称和错误视图名称之间的映射。用于在浏览器应用程序中呈现错误页面。

2. DefaultHandlerExceptionResolver 解决Spring MVC引发的异常并将它们映射到HTTP状态代码。另请参阅备用ResponseEntityExceptionHandler和REST API例外。

3. ResponseStatusExceptionResolver 根据@ResponseStatus注释中的值解决注释中的异常并将其映射到HTTP状态代码。

4. ExceptionHandlerExceptionResolver 通过调用@ExceptionHandler一个@Controller或一个 @ControllerAdvice类中的方法来解决异常。请参阅@ExceptionHandler方法。

对于异常处理来说通常的解决结果有如下的几种方法

1. 使用ModelAndView 指向错误视图。

2. 返回空的modelandview 如果异常被处理

3. 如果异常没有被解决，将会使用异常调用连进行处理，如果调用到最后将会抛出到servlet中

在spring mvc 中集中进行异常处理的有三种方法

1. 使用@ResponseStatus 注释一个异常类，当spring中抛出这个异常的时候将会自动的交由这个类处理,并且可以制定http code值，比如下面的方法将会跑出403错误

```java
package com.zj.exception;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;
@ResponseStatus(value=HttpStatus.FORBIDDEN,reason="用户不匹配")
public class UserNotMatchException extends RuntimeException{}


@RequestMapping("/testResponseStatus")
public String testResponseStatus(int i){
    if(i==0)
        throw new UserNotMatchException();
    return "hello";
}

```

注意如果这个注解使用在 一个方法上的时候 ， 不论结果如何都将会放回制定的httpcode 异常

```java
@ResponseStatus(value=HttpStatus.FORBIDDEN,reason="用户名不匹配")
@RequestMapping("/testResponseStatus")
public String testResponseStatus(int i){
    if(i==0)
        throw new UserNotMatchException();
    return "hello";
}
```

2.@ControllerAdvice 和 @ExceptionHandler

这两个注解同样用于异常处理

（1）@ExceptionHandler 当一个Controller中有方法加了@ExceptionHandler之后，这个Controller其他方法中没有捕获的异常就会以参数的形式传入加了@ExceptionHandler注解的那个方法中。**注意这个方法要有一个参数，这个参数就是指定要处理的异常**

```java
/**
 * Created by liuruijie.
 * 处理异常的类，需要处理异常的Controller直接继承这个类
 */
public class BaseController {
    /**
     * 处理Controller抛出的异常
     * @param e 异常实例
     * @return Controller层的返回值
     */
    @ExceptionHandler
    @ResponseBody
    public Object expHandler(Exception e){
        if(e instanceof SystemException){
            SystemException ex= (SystemException) e;
            return WebResult.buildResult().status(ex.getCode())
                            .msg(ex.getMessage());
        }else{
            e.printStackTrace();
            return WebResult.buildResult().status(Config.FAIL)
                            .msg("系统错误");
        }
    }
}
```

（2）@ControllerAdvice  实现这个注解的类可以让这个类中 @ExceptionHandler标记的方法实现全觉异常监听

```java
@ControllerAdvice
public class GlobalExceptionHandler {
   //处理自定义的异常
   @ExceptionHandler(SystemException.class) 
   @ResponseBody
   public Object customHandler(SystemException e){
      e.printStackTrace();
      return WebResult.buildResult().status(e.getCode()).msg(e.getMessage());
   }
   //其他未处理的异常
   @ExceptionHandler(Exception.class)
   @ResponseBody
   public Object exceptionHandler(Exception e){
      e.printStackTrace();
      return WebResult.buildResult().status(Config.FAIL).msg("系统错误");
   }
}
```
最后对于springmvc 如果异常没有被处理，spring提供了默认的页面展示异常，使用如下方法配置
xml ： 制定默认错误页面
```xml
<error-page>
    <location>/error</location>
</error-page>
```
 java ： 处理url
 ```java
@RestController
public class ErrorController {
    @RequestMapping(path = "/error")
    public Map<String, Object> handle(HttpServletRequest request) {
        Map<String, Object> map = new HashMap<String, Object>();
        map.put("status", request.getAttribute("javax.servlet.error.status_code"));
        map.put("reason", request.getAttribute("javax.servlet.error.message"));
        return map;
    }
}
 ```







