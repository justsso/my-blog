### spring javabean的生命周期

- 使用配置文件的方法

> 注意 <beans>标签中可以配置全局使用的初始化方法和销毁方法

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"
	default-init-method="" default-destroy-method="">
	<bean id="mybean" class="h_Bean的生命周期.MyBean" init-method="init"
		destroy-method="Mydestroy">  <!-- 使用init-method 的 destroy—method 方法指定生命周期的指定和完成方法 -->
	</bean>
</beans>
```

- 使用注解和接口相关的配置方法

```java
import org.springframework.beans.factory.DisposableBean;
import org.springframework.beans.factory.InitializingBean;
//使用bean的生命周期配置 - 注意bean的生命周期只是针对单例模式下的bean对象因为对于非单例模式 spring框架只进行创建而不管其他的用途
//所以spring框架对非单利模式不进行生命周期的检测
//InitializingBean接口表示bean对象在全部的依赖关系都被设置之后将会被自动的进行调用
public class MyBean implements InitializingBean,DisposableBean{
	//接口中定义的初始化方法
	public void afterPropertiesSet() throws Exception {}
	//接口中定义的销毁方法
	public void destroy() throws Exception {}
	//配置文件中定义的初始化方法
	public void init(){}
	//配置文件中定义的销毁方法
	public void Mydestroy(){}
	//这些方法的调用顺序是先调用接口的方法再掉用配置文件中的方法
}
```

> 注意：接口的执行优先级无论是初始化或者销毁都比配置文件放有限执行, SmartInitializingSingleton 所有非lazy单例Bean实例化完成后的回调方法

```java
public class MySmartInitializingSingleton implements SmartInitializingSingleton {
    //所有非lazy单例Bean实例化完成后，会调用该方法
    @Override
    public void afterSingletonsInstantiated() {
        System.out.println("单例Bean实例化完成了");
    }
}
```

spring 中bean的生命周期的配置除了使用 xml 指定 的方法之外还能使用注解的方法进行相关的配置

```java
@PostConstruct
public void methodinit(){}
@PreDestroy
public void methoddestry(){};
```

同时spring还提供了让bean和容器进行相关关联bean 方法

```java
public interface Lifecycle {
  void start();
  void stop();
  boolean isRunning();
}

public interface LifecycleProcessor extends Lifecycle {
  void onRefresh();
  void onClose();
}

public interface Phased {
  int getPhase();
}

public interface SmartLifecycle extends Lifecycle, Phased {
  boolean isAutoStartup();
  void stop(Runnable callback);
}

```

所有的bean都可以实现这些接口，然后在容器进行增加或者删除的时候将会自动的执行相关的方法，注意SmartLifecycle 接口中的stop方法将会传入一个实现runnabe接口的类，容器在进行销毁之后将会自动的异步执行这个类中的相关的run方法，Phased的getphase将会设置一个等级，用来表示优先级

**引申 ：spring容器可以使用ctx.registerShutdownHook(); 方法实现优雅停机操作**


### 单例模式下实现内部变量非单例配置
2018-03-05 16:19:54 星期一
> 之前在博客中做过测试，在spring容器中单例模式注入非单例模式属性的时候其实各个元素注入的是相同的类（使用工厂方法进行注入的时候也是如此）（==返回true），想要获取不同的属性就要使用lookup标签

#### 配置文件

> spring框架在抽象类中将会自动使用动态代理实现这个抽象方法，讲指定的bean对象进行返回如果对象实现了借口  spring框架将会使用jdk代理 否则使用cglib代理  推荐使用接口

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
	<bean id="beanone" class="BeanOne" scope="prototype">
		<property name="name" value="beanone2"></property>
		<property name="age" value="1234"></property>
	</bean>
	<bean id="lookupclass" class="LookupClass">
		<lookup-method name="getBeanOne" bean="beanone"></lookup-method>
	</bean>
</beans>
```

#### Lookup类

```java
public abstract class LookupClass {
	abstract public BeanOne getBeanOne();
}
```

#### javabean

```java
public class BeanOne {
	private String name;
	private int age;
	private BeanTwo beanTwo;
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public int getAge() {
		return age;
	}
	public void setAge(int age) {
		this.age = age;
	}
	public BeanTwo getBeanTwo() {
		return beanTwo;
	}
	public void setBeanTwo(BeanTwo beanTwo) {
		this.beanTwo = beanTwo;
	}
	
}
```

### spring监听器

> 其实就是实现一个event 和 一个listener的过程

#### event 一个事件

event 事件并不需要在配置文件中进行配置，是需要使用application手动发出   实现 ApplicationEvent接口

```java

import org.springframework.context.ApplicationEvent;
//实现spring相应首先要进行spring event事件的注册
//这个方法只是一个封装器-用来将事件进行封装通过接口传递到 实现类中 然后在发出事件
public class MyApplicationEvent extends ApplicationEvent{
	private static final long serialVersionUID = 1L;
	Object object =null;
	//注意这里的第一个参数其实没有什么用就是为了个事件一个参数进行生成一个标号 传递过来的source将会在使用后变成空值
	public MyApplicationEvent(Object source,String string) {
		super(source);
		// TODO Auto-generated constructor stub
		this.object=string;
		System.out.println(object.toString());
	}
	public void say(){
		if(this.object!=null){
			System.out.println(object.toString());
		}
		else{
			System.out.println("this object is Null!!");
		}
	}
}
```

#### spring发送event

ApplicationListener   这个监听器需要在bean中进行配置，spring容器会自动的处理event

```java
import org.springframework.context.ApplicationEvent;
import org.springframework.context.ApplicationListener;
import org.springframework.context.event.ContextClosedEvent;
import org.springframework.context.event.ContextRefreshedEvent;
import org.springframework.context.event.ContextStartedEvent;
import org.springframework.context.event.ContextStoppedEvent;
 
import c_spring_applicationContext的事件机制.applicationEvent.MyApplicationEvent;
 
public class MyApplicationListener implements ApplicationListener<ApplicationEvent>{
	@Override
	public void onApplicationEvent(ApplicationEvent arg0) {
		if (arg0 instanceof MyApplicationEvent){
			((MyApplicationEvent) arg0).say();
		}
		//指的是xml文件加载完成并且可用后发出的事件
		if (arg0 instanceof ContextRefreshedEvent){
			((MyApplicationEvent) arg0).say();
		}
		//当ConfigurableApplicationContext 接口的start（）方法的时候触发这个方法 
		if (arg0 instanceof ContextStartedEvent){
			((MyApplicationEvent) arg0).say();
		}
		//当ConfigurableApplicationContext 接口的close（）方法的时候触发这个方法 
		if (arg0 instanceof ContextClosedEvent){
			((MyApplicationEvent) arg0).say();
		}
		//当ConfigurableApplicationContext 接口的stop（）方法的时候触发这个方法 
		if (arg0 instanceof ContextStoppedEvent){
			((MyApplicationEvent) arg0).say();
		}
		//requestHandledEvent web相关的事件 只能使用 dispatcherServlet的web应用当中 当用户请求结束的时候将会自动触发
	}
}
```

#### xml配置文件

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
	<bean id="myapplicationListener" class="c_spring_applicationContext的事件机制.applicationEventListener.MyApplicationListener">
		<!-- 当时用监听方法的时候必须必须将监听listener注册到bean容器内这样spring框架才能自动进行调用 -->
		<!-- event事件spring设计的时候就没有将他设计为能加入进bean容器的方法因为没有空的构造函数 -->
	</bean>
	<!-- 注册了监听器将会自动的进行监听相关的各种event -->
</beans>
```

### spring bean获得容器和自身相关属性

spring 中bean获得spring 需要实现一下两个接口

- ApplicationContextAware
- BeanFactoryAware

```java
import org.springframework.beans.BeansException;
import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.BeanFactoryAware;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
public class TestBean implements ApplicationContextAware,BeanFactoryAware{
	@Override
	public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
		// TODO Auto-generated method stub
		//传入的参数就是需要进行使用的容器
	}
	@Override
	public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
		// TODO Auto-generated method stub
		//传入的参数就是需要进行使用的容器
	}
}
```

spring bean获得自身的相关配置属性使用如下的接口

- BeanClassLoaderAware
- BeanNameAware

```java
import org.springframework.beans.factory.BeanClassLoaderAware;
import org.springframework.beans.factory.BeanNameAware;
public class TestBean implements BeanNameAware,BeanClassLoaderAware{
	@Override
	public void setBeanClassLoader(ClassLoader classLoader) {
		// TODO Auto-generated method stub
		
	}
	@Override
	public void setBeanName(String name) {
		// TODO Auto-generated method stub
		
	}
	
}
```