### 1. 两数之和

给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。
你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。

这题我用了点类似背包问题的思想，总值为k 当前值为n 那么只要判断k-n 这个直在不在就行了，hashmap解决

```java
class Solution {
public int[] twoSum(int[] nums, int target) {
        HashMap<Integer,Integer> hashMap = new HashMap<>();
        for(int a=0;a<nums.length;a++){
            hashMap.put(nums[a],a);
        }
        int[] need = new int[2];
        for (int a=0;a<nums.length;a++){
            int end = target-nums[a];
            if (hashMap.get(end)!=null&&hashMap.get(end)>a){
                need[0]=a;
                need[1]=hashMap.get(end);
                return need;
            }
        }
        return need;
    }
}
```

### 2. 两数相加

给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。

你可以假设除了数字 0 之外，这两个数字都不会以零开头。

示例：

输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)
输出：7 -> 0 -> 8
原因：342 + 465 = 807

没什么java 链表基础，注意java中没有变量的变量

```java
public class Code02 {
    public static int jin;
    public ListNode createNextNode(int l1, int l2, ListNode before) {
        int number = l1 + l2 + jin;
        jin = number / 10;
        number = number % 10;
        ListNode nowNode = new ListNode(number);
        if (before != null) {
            before.next = nowNode;
        } else {
            end = nowNode;
        }
        return nowNode;
    }
    public static ListNode end = null;
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode before = null;
        jin = 0;
        int number1 = l1.val;
        int number2 = l2.val;
        do {
            before = createNextNode(number1, number2, before);
            if (l1 != null) {
                l1 = l1.next;
                number1 = l1 == null ? 0 : l1.val;
            }
            if (l2 != null) {
                l2 = l2.next;
                number2 = l2 == null ? 0 : l2.val;
            }
        } while (l1 != null || l2 != null);

        if (jin > 0) {
            ListNode listNode = new ListNode(jin);
            before.next = listNode;
        }
        return end;
    }
}
```

### 3. 无重复字符的最长子串

给定一个字符串，找出不含有重复字符的最长子串的长度。

示例：

给定 "abcabcbb" ，没有重复字符的最长子串是 "abc" ，那么长度就是3。

给定 "bbbbb" ，最长的子串就是 "b" ，长度是1。

给定 "pwwkew" ，最长子串是 "wke" ，长度是3。请注意答案必须是一个子串，"pwke" 是 子序列  而不是子串。

这题有点意思，一开始就是自己想复杂了，用到了dp但是实际上根本不需要使用dp，其实就是一种找规律（窗体），和一定的优化方法（真的需要多一次遍历来进行去重吗），不要局限于之前的思想，要灵活

使用多一次循环去重
```java
public class Code03 {
    public int lengthOfLongestSubstring(String s) {
        if (s.length()==0){
            return 0;
        }
        char[] at=s.toCharArray();
        int start = 0;
        int end =1;
        int maxLength=1;
        int nowLength=1;
        HashMap<Character,Integer> map = new HashMap<>();
        map.put(at[0],0);
        while(end<at.length){
            Integer integer = map.get(at[end]);
            if (integer!=null){
                nowLength-=integer-start+1;
                start=integer+1;
                map.clear();
                for (int a=start;a<end;a++){
                    map.put(at[a],a);
                }
            }
            map.put(at[end],end);
            end++;
            nowLength++;
            maxLength = maxLength>nowLength?maxLength:nowLength;
        }
        return maxLength;
    }
}
```
不使用循环去重
```java
class Solution {
         public int lengthOfLongestSubstring(String s) {
       int[] map = new int[256];
        for (int a=0;a<map.length;a++){
            map[a]=-1;
        }
        char[] at = s.toCharArray();
        int start=0;
        int length = 0;
        for (int a=0;a<at.length;a++){
            if (map[at[a]]>=start){
                start= map[at[a]]+1;

            }
            length= Math.max(length,a-start+1);
            map[at[a]]=a;
        }
        return length;
    }
}
```